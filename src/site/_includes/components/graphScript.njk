<script>
    async function fetchGraphData() {
        const graphData = await fetch('/graph.json').then(res => res.json());
        const fullGraphData  = filterFullGraphData(graphData);
        return {graphData, fullGraphData}
    }

    function getNextLevelNeighbours(existing, remaining) {
        // Use Set for O(1) lookup instead of indexOf O(n)
        const keysSet = new Set();
        Object.values(existing).forEach((n) => {
            if (n.neighbors) {
                n.neighbors.forEach(neighbor => keysSet.add(neighbor));
            }
        });
        
        const n_remaining = Object.keys(remaining).reduce((acc, key) => {
                if (keysSet.has(key)) {
                    if (!remaining[key].hide) {
                        existing[key] = remaining[key];
                    }
                } else {
                    acc[key] = remaining[key];
                }
                return acc;
            }, {});
        return [existing, n_remaining];
    }

    function filterLocalGraphData(graphData, depth) {
        if (graphData == null) {
            return null;
        }
        let remaining = JSON.parse(JSON.stringify(graphData.nodes));
        let links = JSON.parse(JSON.stringify(graphData.links));
        let currentLink = decodeURI(window.location.pathname);
        let currentNode = remaining[currentLink] || Object.values(remaining).find((v) => v.home && !v.isFolder);
        if (!currentNode) return null;
        
        delete remaining[currentNode.url];
        if (!currentNode.home) {
            let home = Object.values(remaining).find((v) => v.home && !v.isFolder);
            if (home) {
                delete remaining[home.url];
            }
        }
        currentNode.current = true;
        let existing = {};
        existing[currentNode.url] = currentNode;
        for (let i = 0; i < depth; i++) {
            [existing, remaining] = getNextLevelNeighbours(existing, remaining);
        }
        nodes = Object.values(existing);
        if (!currentNode.home) {
            nodes = nodes.filter(n => !n.home);
        }
        // Use Set for O(1) lookup instead of indexOf O(n)
        let idsSet = new Set(nodes.map((n) => n.id));
        return {
            nodes,
            links: links.filter(function (con) {
                return idsSet.has(con.target) && idsSet.has(con.source);
            }),
        }
    }

    function getCssVar(variable) {return getComputedStyle(document.body).getPropertyValue(variable)}

    function htmlDecode(input) {
        var doc = new DOMParser().parseFromString(input, "text/html");
        return doc.documentElement.textContent;
    }

    function renderGraph(graphData, id, delay, fullScreen) {
        if (graphData == null) {
            return;
        }
        const el = document.getElementById(id);
        width = el.offsetWidth;
        height = el.offsetHeight;
        const highlightNodes = new Set();
        let hoverNode = null;
        const color = getCssVar("--graph-main") || getCssVar("--text-accent");
        const mutedColor = getCssVar("--graph-muted") || "rgba(255, 255, 255, 0.3)";
        const linkColor = getCssVar("--graph-link-color") || "rgba(255, 255, 255, 0.4)";
        const nodeColor = getCssVar("--graph-node-color") || getCssVar("--text-accent");
        const nodeHover = getCssVar("--graph-node-hover") || getCssVar("--text-accent-hover");
        const nodeCurrent = getCssVar("--graph-node-current") || getCssVar("--text-accent");
        
        let Graph = ForceGraph()
        (el)
            .graphData(graphData)
            .nodeId('id')
            .nodeLabel('title')
            .linkSource('source')
            .linkTarget('target')
            .d3AlphaDecay(0.10)
            .d3VelocityDecay(0.4)
            .width(width)
            .height(height)
            .linkDirectionalArrowLength(3)
            .linkDirectionalArrowRelPos(0.5)
            .autoPauseRedraw(false)
            .enableNodeDrag(true)
            .enableZoomInteraction(true)
            .enablePanInteraction(true)
            .zoom(1)
            .minZoom(0.1)
            .maxZoom(4)
            .linkColor((link) => {
                if (hoverNode == null) {
                    return linkColor;
                }
                if (link.source.id == hoverNode.id || link.target.id == hoverNode.id) {
                    return color;
                } else {
                    return mutedColor;
                }
            })
            .linkWidth((link) => {
                if (hoverNode == null) {
                    return 1;
                }
                if (link.source.id == hoverNode.id || link.target.id == hoverNode.id) {
                    return 2;
                } else {
                    return 0.5;
                }
            })
            .nodeColor((node) => {
                // Current node
                if (node.current) {
                    return nodeCurrent;
                }
                // Color nodes by group/folder
                if (node.group && node.group !== "none") {
                    // Generate color based on group name hash with better saturation
                    let hash = 0;
                    for (let i = 0; i < node.group.length; i++) {
                        hash = node.group.charCodeAt(i) + ((hash << 5) - hash);
                    }
                    // Use HSL color space with better saturation and lightness for dark theme
                    const hue = Math.abs(hash % 360);
                    const saturation = 65;
                    const lightness = 55;
                    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                }
                return nodeColor;
            })
            .nodeCanvasObject((node, ctx) => {
                const numberOfNeighbours = (node.neighbors && node.neighbors.length) || 2;
                const nodeR = Math.min(7, Math.max(numberOfNeighbours / 2, 2));
                
                // Get node color based on group
                let nodeColorValue = nodeColor;
                if (node.current) {
                    nodeColorValue = nodeCurrent;
                } else if (node.group && node.group !== "none") {
                    let hash = 0;
                    for (let i = 0; i < node.group.length; i++) {
                        hash = node.group.charCodeAt(i) + ((hash << 5) - hash);
                    }
                    const hue = Math.abs(hash % 360);
                    nodeColorValue = `hsl(${hue}, 65%, 55%)`;
                }
                
                // Determine fill color based on hover state
                let fillColor = nodeColorValue;
                if (hoverNode != null) {
                    if (node == hoverNode || highlightNodes.has(node.url)) {
                        fillColor = node == hoverNode ? nodeHover : nodeColorValue;
                    } else {
                        fillColor = mutedColor;
                    }
                }
                
                // Node glow effect
                const glowRadius = node == hoverNode ? nodeR + 4 : (node.current ? nodeR + 2 : 0);
                if (glowRadius > 0) {
                    const gradient = ctx.createRadialGradient(node.x, node.y, nodeR, node.x, node.y, glowRadius);
                    gradient.addColorStop(0, fillColor);
                    gradient.addColorStop(0.5, fillColor + '80');
                    gradient.addColorStop(1, fillColor + '00');
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = fillColor;
                }
                
                // Different styling for folder nodes
                if (node.isFolder) {
                    fillColor = mutedColor;
                    // Draw folder as a square/rectangle
                    const size = nodeR * 1.5;
                    ctx.fillStyle = fillColor;
                    ctx.fillRect(node.x - size/2, node.y - size/2, size, size);
                } else {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, nodeR, 0, 2 * Math.PI, false);
                    ctx.fillStyle = fillColor;
                    ctx.fill();
                }
                
                // Reset shadow
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
                
                // Highlight current node vá»›i glow
                if (node.current) {
                    ctx.beginPath();
                    if (node.isFolder) {
                        const size = nodeR * 1.5;
                        ctx.rect(node.x - size/2 - 1.5, node.y - size/2 - 1.5, size + 3, size + 3);
                    } else {
                        ctx.arc(node.x, node.y, nodeR + 1.5, 0, 2 * Math.PI, false);
                    }
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = nodeCurrent;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = nodeCurrent;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                // Hover glow effect
                if (node == hoverNode) {
                    ctx.beginPath();
                    if (node.isFolder) {
                        const size = nodeR * 1.5;
                        ctx.rect(node.x - size/2 - 2, node.y - size/2 - 2, size + 4, size + 4);
                    } else {
                        ctx.arc(node.x, node.y, nodeR + 2, 0, 2 * Math.PI, false);
                    }
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = nodeHover;
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = nodeHover;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Draw label
                const label = htmlDecode(node.title);
                const fontSize = 3.5;
                ctx.font = `${fontSize}px Sans-Serif`;
                ctx.fillStyle = getCssVar("--text-normal") || "#dcddde";
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(label, node.x, node.y + nodeR + 2);
            })
            .onNodeClick(node => {
                // If it's a folder node, navigate to first file in folder
                if (node.isFolder && node.firstFileUrl) {
                    window.location = node.firstFileUrl;
                } else if (!node.isFolder) {
                    window.location = node.url;
                }
            })
            .onNodeHover(node => {
                highlightNodes.clear();
                if (node) {
                highlightNodes.add(node);
                node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
                }
                hoverNode = node || null;
                
            });
            if (fullScreen || (delay != null && graphData.nodes.length > 4)) {
                setTimeout(() => {
                    Graph.zoomToFit(5, 75);
                }, delay || 200);
            }
        return Graph;
    }

    function renderLocalGraph(graphData, depth, fullScreen) {
        if (window.graph){
            window.graph._destructor();
        }
        const data = filterLocalGraphData(graphData, depth);
        return renderGraph(data, 'link-graph', null, fullScreen);
    }

    function filterFullGraphData(graphData) {
        if (graphData == null) {
            return null;
        }
        graphData = JSON.parse(JSON.stringify(graphData));
        // Use Set for O(1) lookup
        const hiddensSet = new Set(Object.values(graphData.nodes).filter((n) => n.hide).map((n) => n.id));
        const data = {
            links: JSON.parse(JSON.stringify(graphData.links)).filter((l) => !hiddensSet.has(l.source) && !hiddensSet.has(l.target)),
            nodes: [...Object.values(graphData.nodes).filter((n) => !n.hide || n.isFolder)]
        }
        return data
    }

    function openFullGraph(fullGraphData) {
        lucide.createIcons({
                attrs: {
                    class: ["svg-icon"]
                }
            });
        return renderGraph(fullGraphData, "full-graph-container", 200, false);;
    }

    function closefullGraph(fullGraph) {
        if (fullGraph) {
            fullGraph._destructor();
        }
        return null;
    }
</script>
<div  x-init="{graphData, fullGraphData} = await fetchGraphData();" 
      x-data="{ 
        graphData: null, 
        depth: 1, 
        graph: null, 
        fullGraph: null, 
        showFullGraph: false, 
        fullScreen: false, 
        fullGraphData: null,
        showFilters: false,
        filters: {
          tags: false,
          attachments: false,
          existingFilesOnly: true,
          orphans: true
        },
        groups: [],
        newGroupPath: '',
        display: {
          arrows: false,
          textFadeThreshold: 50,
          nodeSize: 25,
          linkThickness: 1
        },
        forces: {
          centerForce: 50,
          repelForce: 50,
          linkForce: 50,
          linkDistance: 50
        },
        animate: false
      }" 
      id="graph-component" 
      x-bind:class="fullScreen ? 'graph graph-fs' : 'graph'" 
      v-scope>
    <div class="graph-title-container">
        <div class="graph-title">Connected Pages</div>
        <div id="graph-controls">
                <div class="depth-control">
                    <label for="graph-depth">Depth</label>
                    <div class="slider">
                            <input x-model.number="depth" name="graph-depth" list="depthmarkers" type="range" step="1" min="1" max="3" id="graph-depth"/>
                    <datalist id="depthmarkers">
                            <option value="1" label="1"></option>
                            <option value="2" label="2"></option>
                            <option value="3" label="3"></option>
                    </datalist>
                    </div>
                    <span id="depth-display" x-text="depth"></span>
                </div>
                <div class="ctrl-right">
                    <span id="graph-filters-btn" x-on:click="showFilters = !showFilters" title="Filters">
                        <i icon-name="filter" aria-hidden="true"></i>
                    </span>
                    <span id="global-graph-btn" x-on:click="showFullGraph = true; setTimeout(() => {fullGraph = openFullGraph(fullGraphData)}, 100)"><i  icon-name="globe" aria-hidden="true"></i></span>
                    <span  id="graph-fs-btn"  x-on:click="fullScreen = !fullScreen"><i  icon-name="expand" aria-hidden="true"></i></span>
                </div>
        </div>
    </div>
    
    {# Graph Filters Panel #}
    <div class="graph-filters-panel" x-show="showFilters" x-transition style="display: none;">
        <div class="graph-filters-header">
            <h3 class="graph-filters-title">Filters</h3>
            <div class="graph-filters-actions">
                <button class="graph-filters-refresh" title="Refresh">
                    <i icon-name="refresh-cw"></i>
                </button>
                <button class="graph-filters-close" @click="showFilters = false" title="Close">
                    <i icon-name="x"></i>
                </button>
            </div>
        </div>
        
        <div class="graph-filters-search">
            <i icon-name="search"></i>
            <input type="text" placeholder="Search files..." x-model="newGroupPath">
        </div>
        
        {# Filters Section #}
        <div class="graph-filters-section">
            <h4 class="graph-filters-section-title">Filters</h4>
            <div class="graph-filters-list">
                <label class="graph-filter-item">
                    <span>Tags</span>
                    <input type="checkbox" x-model="filters.tags" class="graph-toggle">
                </label>
                <label class="graph-filter-item">
                    <span>Attachments</span>
                    <input type="checkbox" x-model="filters.attachments" class="graph-toggle">
                </label>
                <label class="graph-filter-item">
                    <span>Existing files only</span>
                    <input type="checkbox" x-model="filters.existingFilesOnly" class="graph-toggle">
                </label>
                <label class="graph-filter-item">
                    <span>Orphans</span>
                    <input type="checkbox" x-model="filters.orphans" class="graph-toggle">
                </label>
            </div>
        </div>
        
        {# Groups Section #}
        <div class="graph-filters-section">
            <h4 class="graph-filters-section-title">Groups</h4>
            <div class="graph-groups-list">
                <template x-for="(group, index) in groups" :key="index">
                    <div class="graph-group-item">
                        <span class="graph-group-color" :style="'background: ' + (group.color || '#87CEEB')"></span>
                        <span class="graph-group-path" x-text="'path:\"' + group.path + '\"'"></span>
                        <button class="graph-group-remove" @click="groups.splice(index, 1)">
                            <i icon-name="x"></i>
                        </button>
                    </div>
                </template>
                <button class="graph-group-new" @click="if(newGroupPath) { groups.push({path: newGroupPath, color: '#' + Math.floor(Math.random()*16777215).toString(16)}); newGroupPath = ''; }">
                    New group
                </button>
            </div>
        </div>
        
        {# Display Section #}
        <div class="graph-filters-section">
            <h4 class="graph-filters-section-title">Display</h4>
            <div class="graph-filters-list">
                <label class="graph-filter-item">
                    <span>Arrows</span>
                    <input type="checkbox" x-model="display.arrows" class="graph-toggle">
                </label>
                <label class="graph-filter-item">
                    <span>Text fade threshold</span>
                    <input type="range" x-model.number="display.textFadeThreshold" min="0" max="100" class="graph-slider">
                </label>
                <label class="graph-filter-item">
                    <span>Node size</span>
                    <input type="range" x-model.number="display.nodeSize" min="5" max="50" class="graph-slider">
                </label>
                <label class="graph-filter-item">
                    <span>Link thickness</span>
                    <input type="range" x-model.number="display.linkThickness" min="0.5" max="5" step="0.1" class="graph-slider">
                </label>
                <button class="graph-animate-btn" @click="animate = !animate" :class="{ 'active': animate }">
                    Animate
                </button>
            </div>
        </div>
        
        {# Forces Section #}
        <div class="graph-filters-section">
            <h4 class="graph-filters-section-title">Forces</h4>
            <div class="graph-filters-list">
                <label class="graph-filter-item">
                    <span>Center force</span>
                    <input type="range" x-model.number="forces.centerForce" min="0" max="100" class="graph-slider">
                </label>
                <label class="graph-filter-item">
                    <span>Repel force</span>
                    <input type="range" x-model.number="forces.repelForce" min="0" max="100" class="graph-slider">
                </label>
                <label class="graph-filter-item">
                    <span>Link force</span>
                    <input type="range" x-model.number="forces.linkForce" min="0" max="100" class="graph-slider">
                </label>
                <label class="graph-filter-item">
                    <span>Link distance</span>
                    <input type="range" x-model.number="forces.linkDistance" min="0" max="100" class="graph-slider">
                </label>
            </div>
        </div>
    </div>
    
    <div x-effect="window.graph = renderLocalGraph(graphData, depth, fullScreen)" id="link-graph" ></div>
    <div x-show="showFullGraph" id="full-graph" class="show" style="display: none;">
        <span id="full-graph-close" x-on:click="fullGraph = closefullGraph(fullGraph); showFullGraph = false;"><i icon-name="x" aria-hidden="true"></i></span><div id="full-graph-container"></div>
    </div>
</div>